#!/usr/bin/python3
"""
Asterisk AMI client to recall on busy extensions.

Copyright (C) 2024 Nethesis S.r.l.
SPDX-License-Identifier: GPL-3.0-or-later
"""

import asyncio
import configparser
import os
import re
import sys

class AMIClient:
	def __init__(self, config_path='/etc/asterisk/recallonbusy.cfg'):
		self.config_path = config_path
		self._load_config()
		self.reader = None
		self.writer = None
		self.event_listeners = []  # List of async event listener callbacks
		self.debug = self.config.getboolean('recallonbusy', 'Debug', fallback=False)
		self.check_interval = self.config.getint('recallonbusy', 'CheckInterval', fallback=20)

	def _load_config(self):
		"""Load configuration from the specified file."""
		self.config = configparser.ConfigParser()
		if not os.path.exists(self.config_path):
			raise FileNotFoundError(f"Configuration file not found: {self.config_path}")
		self.config.read(self.config_path)
		self.host = self.config.get('recallonbusy', 'Host', fallback='localhost')
		self.port = self.config.getint('recallonbusy', 'Port', fallback=5038)
		self.username = self.config.get('recallonbusy', 'Username', fallback='')
		self.secret = self.config.get('recallonbusy', 'Secret', fallback='')

	async def connect(self):
		"""Establish a connection to the AMI."""
		print(f"[recallonbusy] Connecting to {self.host}:{self.port}")
		self.reader, self.writer = await asyncio.open_connection(self.host, self.port)
		await self._login()
		# Start listening for events as a background task
		asyncio.create_task(self._listen())

	async def _login(self):
		"""Send the login action to AMI."""
		action = (
			f"Action: Login\r\n"
			f"Username: {self.username}\r\n"
			f"Secret: {self.secret}\r\n\r\n"
		)
		self.writer.write(action.encode())
		await self.writer.drain()
		if self.debug:
			print("[recallonbusy] DEBUG: Sent login action")

	async def _listen(self):
		"""Continuously listen for incoming data from AMI."""
		if self.debug:
			print("[recallonbusy] DEBUG: Started listener task")
		buffer = ''
		while True:
			try:
				data = await self.reader.read(4096)
				if not data:
					break
				buffer += data.decode()
				# Process complete events separated by double CRLF
				while '\r\n\r\n' in buffer:
					raw_event, buffer = buffer.split('\r\n\r\n', 1)
					event = self._parse_event(raw_event)
					await self._handle_event(event)
			except Exception as e:
				print(f"[recallonbusy] ERROR in listener task: {e}", file=sys.stderr)
				break

	def _parse_event(self, data):
		"""Parse raw event data into a dictionary."""
		event = {}
		for line in data.strip().split('\r\n'):
			if ': ' in line:
				key, value = line.split(': ', 1)
				event[key.strip()] = value.strip()
		if self.debug:
			print(f"[recallonbusy] DEBUG: Parsed event: {event}")
		return event

	async def _handle_event(self, event):
		"""Notify all listeners about the event."""
		for listener in self.event_listeners:
			await listener(event)

	def add_event_listener(self, listener):
		"""Add an asynchronous listener for AMI events."""
		self.event_listeners.append(listener)

	def remove_event_listener(self, listener):
		"""Remove a listener from AMI events."""
		if listener in self.event_listeners:
			self.event_listeners.remove(listener)

	async def send_action(self, action_dict):
		"""Send an action to the AMI."""
		action = ''.join(f"{key}: {value}\r\n" for key, value in action_dict.items())
		action += '\r\n'
		self.writer.write(action.encode())
		await self.writer.drain()
		if self.debug:
			print(f"[recallonbusy] DEBUG: Sent action: {action_dict}")

	async def close(self):
		"""Close the connection to the AMI."""
		if self.writer:
			self.writer.close()
			await self.writer.wait_closed()
			if self.debug:
				print("[recallonbusy] DEBUG: Closed connection to AMI")


async def main():
	# Global device state mapping
	device_state_map = {}
	client = AMIClient('/etc/asterisk/recallonbusy.cfg')

	async def device_state_change_event_listener(event):
		"""Handle DeviceStateChange AMI events."""
		if 'Event' not in event or event['Event'] != 'DeviceStateChange':
			return
		if client.debug:
			print(f"[recallonbusy] DEBUG: Handling event: {event}")

		if 'State' in event and 'Device' in event and re.match(r'^PJSIP/[0-9]{2,}$', event['Device']):
			# Extract the main extension from the device string
			mainextension = re.sub(r'^PJSIP/9[0-9]([0-9]+)$|^PJSIP/([^9][0-9]+)$', r'\1\2', event['Device'])
			device_state_map[mainextension] = event['State']
			if event['State'] == 'NOT_INUSE':
				if client.debug:
					print(f"[recallonbusy] DEBUG: Device {mainextension} is NOT_INUSE, checking for waiting extensions")
				# Send DBGet to fetch waiting extensions
				await client.send_action({
					'Action': 'DBGet',
					'ActionID': f'{mainextension}_get_waiting',
					'Family': 'ROB',
					'Key': mainextension
				})

	async def db_get_response_event_listener(event):
		"""Handle DBGetResponse AMI events."""
		if 'Event' not in event or event['Event'] != 'DBGetResponse':
			return
		if client.debug:
			print(f"[recallonbusy] DEBUG: Handling event: {event}")

		if (event.get('Family') == 'ROB' and 'Key' in event and
			'Val' in event and event['Val'] != '' and 
			'ActionID' in event and re.match(r'^[0-9]+_get_waiting$', event['ActionID'])):
			mainextension = re.sub(r'^([0-9]+)_get_waiting$', r'\1', event['ActionID'])
			waiting_extensions = event['Val'].split('&')
			if client.debug:
				print(f"[recallonbusy] DEBUG: Waiting extensions for {mainextension}: {waiting_extensions}")
			for waiting_extension in waiting_extensions:
				waiting_state = device_state_map.get(waiting_extension)
				if waiting_state in ['NOT_INUSE', 'UNKNOWN']:
					print(f"[recallonbusy] Calling waiting extension {waiting_extension}")
					await client.send_action({
						'Action': 'Originate',
						'Channel': f'Local/{waiting_extension}@from-internal',
						'Context': 'from-internal',
						'Timeout': 150000,
						'CallerID': mainextension,
						'Exten': mainextension,
						'Priority': 1
					})
					# Remove the called waiting extension and update the database
					waiting_extensions.remove(waiting_extension)
					await client.send_action({
						'Action': 'DBPut',
						'Family': 'ROB',
						'Key': mainextension,
						'Val': '&'.join(waiting_extensions)
					})
					break
				elif client.debug:
					print(f"[recallonbusy] DEBUG: Skipping waiting extension {waiting_extension}: {waiting_state}")

	# Register the asynchronous event listeners
	client.add_event_listener(device_state_change_event_listener)
	client.add_event_listener(db_get_response_event_listener)

	# Attempt to connect until successful
	while True:
		try:
			await client.connect()
			break
		except ConnectionRefusedError:
			print("[recallonbusy] Connection to AMI refused, retrying in 5 seconds...")
			await asyncio.sleep(5)
		except Exception as e:
			print(f"[recallonbusy] ERROR connecting to AMI: {e}")
			await asyncio.sleep(30)

	# Continuously send a DeviceStateList action at the configured interval
	while True:
		try:
			await client.send_action({'Action': 'DeviceStateList'})
		except Exception as e:
			print(f"[recallonbusy] ERROR sending action: {e}")
			await client.connect()  # Attempt reconnection on error
		await asyncio.sleep(client.check_interval)

if __name__ == '__main__':
	asyncio.run(main())
